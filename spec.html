<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Decorators proposal
stage: 2
contributors: Daniel Ehrenberg, Jeff Morrison, Kevin Smith, Kevin Gibbons, Yehuda Katz, Brian Terlson
</pre>
<style>
emu-example figure {
  align-items: initial;
  width: 100%;
}

emu-note {
  display: block;
  border-left-color: #474747;
}

emu-note span.note {
  display: inline-block;
  color: #fff;
  background-color: #474747;
  width: initial;
  padding-right: 50px;
}

emu-note div.note-contents {
  padding-left: 5px;
}

emu-note[type=editor] {
  border-left-color: #900;
}
emu-note[type=editor] span.note {
  background-color: #900;
}

emu-example {
  border-left: 5px solid #006387;
  margin: 1em 0;
}

emu-example figure figcaption:first-child {
  display: inline-block;
  color: #fff;
  background-color: #006387;
  margin: 0;
  padding: 0 50px 0 5px;
  font-weight: normal;
  text-transform: uppercase;
  margin-left: -5px;
}

emu-example figure figcaption:nth-child(2) {
  margin: 0;
  padding: 0;
  padding-left: 5px;
  margin-left: -5px;
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 10px;
}

emu-example p:nth-of-type(1) {
  margin-top: 0;
}

emu-example figure {
  padding-left: 5px;
  display: block;
  margin: 0;
}

emu-example pre {
  margin: 0;
}
</style>

<emu-intro id=sec-intro>
  <h1>Introduction</h1>
  <p>This proposal adds decorators to JavaScript. It incorporates features needed to make decorators work with the <a href="https://tc39.github.io/proposal-class-fields">class fields</a> and <a href="https://littledan.github.io/proposal-private-methods">private methods</a>. See <a href="https://github.com/tc39/proposal-decorators">the explainer</a> for an overview.</p>

  <p>This document is phrased as a diff against the previous <a href="https://tc39.github.io/proposal-private-methods">private methods</a> proposal, which is in turn a diff against the <a href="https://tc39.github.io/proposal-class-fields">class fields</a> proposal.</p>
</emu-intro>


<emu-clause id=sec-syntax>
  <h1>Syntax</h1>

  <emu-clause id=sec-new-syntax>
    <h1>New Productions</h1>

    <emu-grammar>
      DecoratorList[Yield, Await] :
        DecoratorList[?Yield, ?Await]? Decorator[?Yield, ?Await]

      Decorator[Yield, Await] :
        `@` DecoratorMemberExpression[?Yield, ?Await]
        `@` DecoratorCallExpression[?Yield, ?Await]

      DecoratorMemberExpression[Yield, Await] :
        IdentifierReference[?Yield, ?Await]
        DecoratorMemberExpression[?Yield, ?Await] `.` IdentifierName
        `(` Expression[+In, ?Yield, ?Await] `)`

      DecoratorCallExpression[Yield, Await] :
        DecoratorMemberExpression Arguments[?Yield, ?Await]
    </emu-grammar>
  </emu-clause>

  <emu-clause id=sec-updated-syntax>
    <h1>Updated Productions</h1>

    <emu-grammar>
      ClassElement[Yield, Await] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> MethodDefinition[?Yield, ?Await]
        <ins>DecoratorList[?Yield, ?Await]?</ins> `static` MethodDefinition[?Yield, ?Await]
        <ins>DecoratorList[?Yield, ?Await]?</ins> FieldDefinition[?Yield, ?Await] `;`
        <ins>DecoratorList[?Yield, ?Await]?</ins> `static` FieldDefinition[?Yield, ?Await] `;`

      ClassDeclaration[Yield, Await, Default] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] <ins>DecoratorList[?Yield, ?Await]?</ins> `class` ClassTail[?Yield, ?Await]
    </emu-grammar>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-new-ecmascript-specification-types">
  <h1>New ECMAScript Specification Types</h1>

  <emu-clause id="sec-classes-specification-types">
    <h1>Classes Specification Types</h1>

    <emu-clause id="sec-elementdescriptor-specification-type" aoid=ElementDescriptor>
      <h1>The ElementDescriptor Specification Type</h1>

      <p>
        The <dfn>ElementDescriptor</dfn> is a Record used to represent class elements at runtime.
        Values of the ElementDescriptor type are Record values whose fields are defined as by <emu-xref href="#table-element-descriptor-fields"></emu-xref>.
        Unless otherwise specified, every field is always present.
      </p>

      <emu-table id="table-element-descriptor-fields" caption="ElementDescriptor fields">
        <table>
          <thead>
            <tr> <th>Field Name</th>      <th>Value</th>                                                          </tr>
          </thead>
          <tbody>
            <tr> <td>[[Kind]]</td>        <td>One of `"method"` or `"field"`</td>                                  </tr>
            <tr> <td>[[Key]]</td>         <td>A Property Key or %PrivateName% object</td>                          </tr>
            <tr> <td>[[Descriptor]]</td>  <td>A Property Descriptor</td>                                           </tr>
            <tr> <td>[[Placement]]</td>   <td>One of `"static"`, `"prototype"` or `"own"`</td>                     </tr>
            <tr> <td>[[Initializer]]</td> <td>A function or ~empty~. This field can be absent.</td>                </tr>
            <tr> <td>[[Decorators]]</td>  <td>A List of ECMAScript language values. This field can be absent.</td> </tr>
          </tbody>
        </table>
      </emu-table>

      <p>
        In addition, given an ElementDescriptor _element_, the following conditions are always respected:
        <ul>
          <li>If _element_.[[Kind]] is `"method"`, then _element_.[[Initializer]] is not present.</li>
          <li>
            If _element_.[[Kind]] is `"field"`, then
            <ul>
              <li>_element_.[[Initializer]] is present.</li>
              <li>_element_.[[Descriptor]]'s [[Get]], [[Set]] and [[Value]] slots are absent.</li>
            </ul>
          </li>
          <li>
            If _element_.[[Key]] is a Private Name, then
            <ul>
              <li>_element_.[[Placement]] is `"own"`.</li>
              <li>_element_.[[Descriptor]].[[Enumerable]] is *false*.</li>
              <li>_element_.[[Descriptor]].[[Configurable]] is *false*.</li>
            </ul>
          </li>
        </ul>
      </p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-internal-algorithms">
<h1>Modified class algorithms</h1>

  <emu-clause id="runtime-semantics-class-definition-evaluation">
    <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
    <p>With parameter _className_ and optional parameter _decorators_.</p>
    <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
    <emu-alg>
      1. Let _lex_ be the LexicalEnvironment of the running execution context.
      1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
      1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.CreateImmutableBinding(_className_, *true*).
      1. <ins>Let _outerPrivateEnvironment_ be the PrivateNameEnvironment of the running execution context.</ins>
      1. <ins>Let _classPrivateEnvironment_ be NewDeclarativeEnvironment(_outerPrivateEnvironment_).</ins>
      1. <ins>Let _classPrivateEnvRec_ be _classPrivateEnvironment_'s EnvironmentRecord.</ins>
      1. <ins>If |ClassBody_opt| is present, then</ins>
        1. <ins>For each element _dn_ of the PrivateBoundNames of |ClassBody_opt|,</ins>
          1. <ins>Perform _classPrivateEnvRec_.CreateImmutableBinding(_dn_, *true*).</ins>
      1. If |ClassHeritage_opt| is not present, then
        1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
        1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
      1. Else,
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Let _superclass_ be the result of evaluating |ClassHeritage|.
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. ReturnIfAbrupt(_superclass_).
        1. If _superclass_ is *null*, then
          1. Let _protoParent_ be *null*.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
        1. Else,
          1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
          1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _constructorParent_ be _superclass_.
      1. Let _proto_ be ObjectCreate(_protoParent_).
      1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
      1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
      1. If _constructor_ is ~empty~, then
        1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
        1. Else,
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor( ){ }</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
      1. Set the running execution context's LexicalEnvironment to _classScope_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _classPrivateEnvironment_.</ins>
      1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
      1. Assert: _constructorInfo_ is not an abrupt completion.
      1. Let _F_ be _constructorInfo_.[[Closure]].
      1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then set _F_.[[ConstructorKind]] to `"derived"`.
      1. Perform MakeConstructor(_F_, *false*, _proto_).
      1. Perform MakeClassConstructor(_F_).
      1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
      1. If |ClassBody_opt| is not present, let <del>_methods_</del><ins>_elements_</ins> be a new empty List.
      1. Else, let <del>_methods_</del><ins>_definitions_</ins> be <del>NonConstructorMethodDefinitions</del><ins>NonConstructorElementDefinitions</ins> of |ClassBody|. <ins>NOTE: Simply renaming this internal algorithm will be enough; it includes fields.</ins>
      1. <ins>Let _elements_ be a new empty List.</ins>
      1. For each |ClassElement| <del>_m_</del><ins>_d_</ins> in order from <del>_methods_</del><ins>_definitions_</del>,
        1. <del>If IsStatic of _m_ is *false*, then</del>
          1. <del>Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _proto_ and *false*.</del>
        1. <del>Else,</del>
          1. <del>Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _F_ and *false*.</del>
        1. <ins>Let _newElements_ be the result of performing ClassElementEvaluation for _d_ with arguments _F_, _true_, and ~empty~.</ins>
        1. If <del>_status_</del><ins>_newElements_</ins> is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
          1. Return Completion(_status_).
        1. <ins>Append _newElements_ to _elements_</ins>
      1. <ins>Let _elements_ be CoalesceClassElements(_elements_).</ins>
      1. <ins>If _decorators_ is not provided, let _decorators_ be a new empty List.</ins>
      1. <ins>Let _decorated_ be ? DecorateClass(_elements_, _decorators_).</ins>
      1. Set the running execution context's LexicalEnvironment to _lex_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.InitializeBinding(_className_, _F_).
      1. <ins>Set the value of _F_'s [[Elements]] internal slot to _decorated_.[[Elements]].</ins>
      1. <ins>Perform ? InitializeClassElements(_F_, _proto_).</ins>
      1. <del>Return _F_.</del>
      1. <ins>Return ? RunClassFinishers(_F_, _decorated_.[[Finishers]]).</ins>
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-method-definitions-runtime-semantics-propertydefinitionevaluation">
    <h1>Runtime Semantics: ClassElementEvaluation</h1>
    <p>With parameters _homeObject_, _enumerable_ and _placement_.</p>
    <p>ClassElementEvaluation returns a List of ElementDescriptor Records.</p>
    <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
    <emu-grammar>ClassElement : <ins>DecoratorList?</ins> MethodDefinition</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ?</ins> ClassElementEvaluation of |MethodDefinition| with arguments ! Get(_homeObject_, `"prototype"`),_enumerable_, and `"prototype"`.
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
    </emu-alg>
    <emu-grammar>ClassElement : <ins>DecoratorList?</ins> `static` MethodDefinition</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ?</ins> ClassElementEvaluation of |MethodDefinition| with arguments _homeObject_, _enumerable_ and `"static"`.
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
    </emu-alg>
  <emu-grammar>ClassElement : <ins>DecoratorList?</ins> `static` FieldDefinition `;`</emu-grammar>
  <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ? ClassFieldDefinitionEvaluation of FieldDefinitionList with parameters `"static"` and _homeObject_.</ins>
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
  </emu-alg>

  <emu-grammar>ClassElement : <ins>DecoratorList?</ins> FieldDefinition `;`</emu-grammar>
  <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <del>Return</del><ins>Let _elements_ be ? ClassFieldDefinitionEvaluation of FieldDefinitionList with parameters `"own"` and ! Get(_homeObject_, `"prototype"`).</ins>
      1. <ins>If |DecoratorList| is present, for _element_ in _elements_, set _element_.[[Decorators]] to _decorators_.</ins>
      1. <ins>Return _elements_.</ins>
  </emu-alg>

  </emu-clause>


    <!-- es6num="14.5.15" -->
    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation">
      <h1>Runtime Semantics: BindingClassDeclarationEvaluation</h1>
      <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
        1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
        1. Let _className_ be StringValue of |BindingIdentifier|.
        1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments _className_<ins> and _decorators</ins>.
        1. ReturnIfAbrupt(_value_).
        1. Let _hasNameProperty_ be ? HasOwnProperty(_value_, `"name"`).
        1. If _hasNameProperty_ is *false*, perform SetFunctionName(_value_, _className_).
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Perform ? InitializeBoundName(_className_, _value_, _env_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` ClassTail</emu-grammar>
      <emu-alg>
        1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
        1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
        1. Return the result of ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* <ins>and _decorators_</ins>.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and the setting of a name property and establishing its binding are handled as part of the evaluation action for that production. See <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>.</p>
      </emu-note>
    </emu-clause>

  <emu-clause id="sec-coalesce-getter-setter" aoid=CoalesceGetterSetter>
    <h1>CoalesceGetterSetter ( _element_, _other_ )</h1>
    <emu-alg>
      1. Assert: _element_ and _other_ are both ElementDescriptor Records.
      1. Assert: IsAccessorDescriptor(_other_.[[Descriptor]]) and IsAccessorDescriptor(_element_.[[Descriptor]]) are both *true*,
      1. If _element_.[[Descriptor]] has a [[Get]] field,
        1. Set _other_.[[Descriptor]].[[Get]] to _element_.[[Descriptor]].[[Get]].
      1. Otherwise,
        1. Assert: _element_.[[Descriptor]] has a [[Set]] field.
        1. Set _other_.[[Descriptor]].[[Set]] to _element_.[[Descriptor]].[[Set]].
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-coalesce-class-elements" aoid="CoalesceClassElements">
    <h1>CoalesceClassElements ( _elements_ )</h1>
    <emu-alg>
      1. Assert: _elements_ is a List of ElementDescriptor Records.
      1. Let _newElements_ be an empty List.
      1. For _element_ in _elements_,
        1. If _element_.[[Kind]] is `"method"` and _newElements_ contains a Record _other_ where _other_.[[Kind]] is `"method"`, SameValue(_other_.[[Key]], _element_.[[Key]]) is *true*, and _other_.[[Placement]] is _element_.[[Placement]],
          1. If _element_.[[Decorators]] is present,
            1. If _other_.[[Decorators]] is present, throw a *ReferenceError* exception.
            1. Set _other_.[[Decorators]] to _element_.[[Decorators]].
          1. If IsDataDescriptor(_element_.[[Descriptor]]) is *true* or IsDataDescriptor(_other_.[[Descriptor]]) is *true*, then
            1. Assert: _element_.[[Key]] is not a Private Name.
            1. Assert: _element_.[[Descriptor]].[[Configurable]] is *true*, and _other_.[[Descriptor]].[[Configurable]] is *true*.
            1. Set _other_.[[Descriptor]] to _element_.[[Descriptor]].
          1. Else,
            1. Perform ! CoalesceGetterSetter(_element_, _other_).
        1. Otherwise, append _element_ to _newElements_.
      1. Return _newElements_.
    </emu-alg>
    <emu-note>In the case of public class elements, coalescing corresponds in semantics to ValidateAndApplyPropertyDescriptor. Note that this algorithm only coalesces method and accessor declarations, and it leaves field declarations as is.</emu-note>
  </emu-clause>

</emu-clause>


</emu-clause>

  <emu-clause id="sec-private-name-type-and-objects">
    <h1>PrivateName Objects</h1>

    <emu-note type=editor>
      This section refers to <a href="https://tc39.github.io/proposal-class-fields/#sec-private-names">Private Name values</a>, as defined in the class fields proposal.
    </emu-note>

  <emu-clause id="sec-private-name-objects">
    <h1>Private Name Objects</h1>
    <emu-clause id="sec-private-name-constructor">
      <h1>The %PrivateName% Constructor</h1>
      <p>The Private Name constructor is the <dfn>%PrivateName%</dfn> intrinsic object. When %PrivateName% is constructed with `new`, it returns a new object which wraps a Private Name value. The %PrivateName% intrinsic does not have a global name or appear as a property of the global object.</p>

      <emu-clause id="sec-private-description" aoid=PrivateName>
        <h1>%PrivateName% ( [ _description_ ] )</h1>
        <p>When %PrivateName% is called with optional argument _description_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If _description_ is *undefined*, let _descString_ be *undefined*.
          1. Else, let _descString_ be ? ToString(_description_).
          1. Let _name_ be NewPrivateName(_descString_).
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%PrivateNamePrototype%"`, &laquo; [[PrivateName]] &raquo;).
          1. Set _O_.[[PrivateNameData]] to _name_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-private-name-prototype-object">
      <h1>Properties of the %PrivateNamePrototype% Object</h1>
      <p>The %PrivateNamePrototype% object is an ordinary object. It is not a %PrivateName% instance and does not have a [[PrivateNameData]] internal slot.</p>
      <p>The value of the [[Prototype]] internal slot of the PrivateName prototype object is the intrinsic object %ObjectPrototype%.</p>

      <emu-clause id="sec-private-name.prototype.constructor">
        <h1>%PrivateName%.prototype.constructor</h1>
        <p>The initial value of `PrivateName.prototype.constructor` is the intrinsic object %PrivateName%.</p>
      </emu-clause>

      <emu-clause id="sec-private-name-get">
        <h1>%PrivateName%.prototype.get ( _object_ )</h1>
        <p>When invoked, the following steps are taken:</p>
        <emu-alg>
          1. Let _pn_ be ? ThisPrivateName().
          1. If Type(_object_) is not Object, throw a *TypeError* exception.
          1. Return ? PrivateFieldGet(_pn_, _object_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name-set">
        <h1>%PrivateName%.prototype.set ( _object_, _value_ )</h1>
        <p>%PrivateNameSet% is a per-realm built-in function object. When invoked, the following steps are taken:</p>
        <emu-alg>
          1. Let _pn_ be ? ThisPrivateName().
          1. If Type(_object_) is not Object, throw a *TypeError* exception.
          1. Return ? PrivateFieldSet(_pn_, _object_, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype.description">
        <h1>get %PrivateName%.prototype.description ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _pn_ be ? ThisPrivateName().
          1. Let _desc_ be _sym_'s [[Description]] value.
          1. If _desc_ is *undefined*, return _desc_ be the empty string.
          1. Otherwise, return _desc_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype.tostring">
        <h1>%PrivateName%.prototype.toString ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <emu-note>
          Because conversion to a string throws, ToPropertyKey applied to a %PrivateName% object throws as well. This property is important to ensure that Private Names are not incorrectly used by decorators using property access, rather than with their `get` and `set` methods.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype-@@tostringtag">
        <h1>PrivateName.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"PrivateName"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-private-name-this-private-name" aoid=ThisPrivateName>
        <h1>ThisPrivateName()</h1>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have a [[PrivateNameData]] internal slot, throw a *TypeError* exception.
          1. Let _pn_ be _O_.[[PrivateNameData]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-private-name-instances">
      <h1>Properties of PrivateName Instances</h1>
      <p>PrivateName instances are ordinary objects that inherit properties from the PrivateName prototype object. PrivateName instances have a [[PrivateNameData]] internal slot. The [[PrivateNameData]] internal slot is the Private Name value represented by this Private Name object.</p>
    </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="decorator-semantics">
  <h1>Decorator semantics</h1>
  <emu-clause id=sec-decorator-functions>
    <h1>Decorator Functions</h1>
    <p>A <dfn>decorator function</dfn> is a function that takes and returns either a element descriptor or a class descriptor. The body of a decorator function modifies and returns the descriptor it receives to change the semantics of the decorated entity. Descriptor types can be differentiated by their `kind` property, which is either `"method"`, `"field"` or `"class"`. Descriptors also have a @@toStringTag property which is of the form `"Kind Descriptor"`, where `"Kind"` is replaced by the `kind` property with the first letter capitalized; this property helps differentiate them from other objects.</p>
    <emu-clause id=sec-decorator-functions-element-descriptor>
      <h1>Element Descriptors</h1>
      <p>An <dfn>element descriptor</dfn> describes an element of a class or object literal and has the following shape:</p>
      <pre><code class=typescript>
        interface ElementDesciptor {
          kind: "method" or "field"
          key: String, Symbol or Private Name,
          placement: "static", "prototype", or "own"
          descriptor: PropertyDescriptor,
          initializer?: Function
          extras?: ElementDescriptor[]
          finisher?: (klass): undefined or constructor;
        }
      </code></pre>
      The `finisher` and `extra` fields are only present when returning from user code, and are not given as an argument to them, or logically part of the descriptor.
    </emu-clause>
    <emu-clause id=sec-decorator-functions-class-descriptor>
      <h1>Class Descriptors</h1>
      <p>A <dfn>class descriptor</dfn> describes a class and has the following shape:</p>
      <pre><code class=typescript>
        interface ClassDesciptor {
          kind: "class"
          elements: ElementDescriptor[]
          finisher?: (klass): undefined or constructor;
        }
      </code></pre>
    </emu-clause>
  </emu-clause>

    <emu-clause id=sec-decorator-runtime-semantics-decoratorevaluation aoid=DecoratorEvaluation>
      <h1>Runtime Semantics: DecoratorEvaluation</h1>
      <emu-grammar>Decorator : `@` DecoratorMemberExpression[?Yield]</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the result of reparsing |DecoratorMemberExpression| as a |MemberExpression|.
        1. Let _ref_ be the result of evaluating _expr_.
        1. Let _func_ be ? GetValue(_ref_).
        1. Let _value_ be ? EvaluateCall(_func_, _ref_, « », *false*).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>Decorator : `@` DecoratorCallExpression[?Yield]</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the result of reparsing |DecoratorCallExpression| as a |CallMemberExpression|.
        1. Let _ref_ be the result of evaluating _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. Return _value_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-method-definitions-runtime-semantics-decoratorlistevaluation aoid=DecoratorListEvaluation>
      <h1>Runtime Semantics: DecoratorListEvaluation</h1>
      <emu-grammar>DecoratorList : DecoratorList[?Yield]? Decorator[?Yield]</emu-grammar>
      <emu-alg>
        1. If |DecoratorList| is present, then let _leftValue_ be ? DecoratorListEvaluation(|DecoratorList|).
        1. Else, let _leftValue_ be a new empty List.
        1. Let _rightValue_ be ? DecoratorEvaluation(|Decorator|).
        1. Append _rightValue_ to the end of _leftValue_.
        1. Return _leftValue_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-run-class-finishers aoid=RunClassFinishers>
      <h1>RunClassFinishers ( constructor, finishers )</h1>
      <emu-alg>
        1. For each _finisher_ in _finishers_, do
          1. Let _newConstructor_ be Call( _finisher_, *undefined*, « _constructor_ »).
          1. If _newConstructor_ is not *undefined*,
            1. If IsConstructor(_newConstructor_) is *false*, throw a *TypeError* exception.
            1. Let _constructor_ be _newConstructor_.
        1. Return _constructor_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-decorate-class aoid=DecorateClass>
      <h1>DecorateClass ( elements, decorators )</h1>
      <emu-alg>
        1. Let _newElements_, _finishers_, and _keys_ each be a new empty List.
        1. For each _element_ in _elements_, do
          1. Append _element_.[[Key]] to _keys_.
        1. For each _element_ in _elements_, do
          1. Let _elementFinishersExtras_ be ? DecorateElement(_element_, _keys_).
          1. Append _elementFinishersExtras_.[[Element]] to _newElements_.
          1. Concatenate _elementFinishersExtras_.[[Extras]] onto _newElements_.
          1. Concatenate _elementFinishersExtras_.[[Finishers]] onto _finishers_.
        1. Let _result_ be ? DecorateConstructor(_newElements_, _decorators_).
        1. Set _result_.[[Finishers]] to the concatenation of _finishers_ and _result_.[[Finishers]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-decorate-element aoid=DecorateElement>
      <h1>DecorateElement ( element, keys )</h1>
      <p>With parameters _element_, a Class Element and _keys_, a List of Property Keys and Private Names.</p>
      <emu-alg>
        1. Let _extras_ be a new empty List.
        1. Let _finishers_ be a new empty List.
        1. For each _decorator_ in element_.[[Decorators]], in reverse list order do
          1. Assert: _element_.[[Key]] is an element of _keys_.
          1. Remove _element_.[[Key]] from _keys_.
          1. Let _elementObject_ be ? FromElementDescriptor(_element_).
          1. Let _elementFinisherExtrasObject_ be ? Call(_decorator_, *undefined*, « _elementObject_, %PrivateNameGet%, %PrivateNameSet% »).
          1. Let _elementFinisherExtras_ be ? ToElementFinisherExtras(_elementFinisherExtrasObject_).
          1. Let _element_ be _elementFinisherExtras_.[[Element]].
          1. If _element_.[[Key]] is an element of _keys_, throw a *TypeError* exception.
          1. Otherwise, append _element_.[[Key]] to _keys_.
          1. If _elementFinisherExtras_.[[Finisher]] is not *undefined*, then
            1. Append _elementFinisherExtras_.[[Finisher]] to the end of _finishers_.
            1. NOTE: Finishers are not passed forward to the next decorator.
          1. Let _newExtras_ be _elementFinisherExtras_.[[Extras]]
          1. If _newExtras_ is not *undefined*, then
            1. For each _extra_ of _newExtras_, do
              1. If _extra_.[[Key]] is an element of _keys_, throw a *TypeError* exception.
              1. Otherwise, append _extra_.[[Key]] to _keys_.
            1. Concatenate _newExtras_ onto _extras_.
        1. Return the Record {[[Element]]: _element_, [[Extras]]: _extras_, [[Finishers]]: _finishers_}.
      </emu-alg>
    </emu-clause>
    <emu-clause id=sec-decorate-constructor aoid=DecorateConstructor>
      <h1>DecorateConstructor ( elements, decorators )</h1>
      <p>With parameters _elements_, a List of Class Elements, and _decorators_, a List of decorator functions.</p>
      <emu-alg>
        1. Let _finishers_ be a new empty List.
        1. For each _decorator_ in _decorators_, in reverse list order do
          1. Let _obj_ be FromClassDescriptor(_elements_).
          1. Let _result_ be ? Call(_decorator_, *undefined*, « _obj_, %PrivateName% »).
          1. Let _elementsAndFinisher_ be ? ToClassDescriptor(_result_).
          1. If _elementsAndFinisher_.[[Finisher]] is not *undefined*,
            1. Append _elementsAndFinisher_.[[Finisher]] to _finishers_.
          1. If _elementsAndFinisher_.[[Elements]] is not *undefined*,
            1. Set _elements_ to _elementsAndFinisher_.[[Elements]].
            1. If there are two class elements _a_ and _b_ in _elements_ such that _a_.[[Key]] is _b_.[[Key]], throw a *TypeError* exception.
        1. Return the Record { [[Elements]]: _elements_, [[Finishers]]: _finishers_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-from-element-descriptors" aoid=FromElementDescriptors>
      <h1>FromElementDescriptors ( _elements_ )</h1>
      <emu-alg>
          1. Assert: _elements_ is a List of ElementDescriptor.
          1. Let _elementObjects_ be a new empty List.
          1. For each _element_ in _elements_, do
            1. Append FromElementDescriptor(_element_) to _elementObjects_.
          1. Return CreateArrayFromList(_elementObjects_).
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-from-element-descriptor aoid=FromElementDescriptor>
      <h1>FromElementDescriptor ( _element_ )</h1>
      <emu-alg>
        1. Assert: _element_ is an ElementDescriptor.
        1. Let _obj_ be ! ObjectCreate(%ObjectPrototype%).
        1. If _element_.[[Kind]] is `"method"`,
          1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Method Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Otherwise,
          1. Assert: _element_.[[Kind]] is `"field"`.
          1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Field Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Perform ! DefinePropertyOrThrow(_obj_, @@toStringTag, _desc_).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"kind"`, _element_.[[Kind]]).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"key"`, _element_.[[Key]]).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"placement"`, _element_.[[Placement]]).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"descriptor"`, ! FromPropertyDescriptor(_element_.[[Descriptor]])).
        1. If _element_.[[Kind]] is `"field"`,
          1. Let _initializer_ be _element_.[[Initializer]].
          1. If _initializer_ is ~empty~, set _initializer_ to *undefined*.
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"initializer"`, _initializer_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-to-element-descriptors" aoid=ToElementDescriptors>
      <h1>ToElementDescriptors ( _elementObjects_ )</h1>
      <emu-alg>
        1. Assert: _elementObject_ is an ECMAScript language value.
        1. If _elementObjects_ is *undefined*, return *undefined*.
        1. Let _elements_ be a new empty List.
        1. Let _elementObjectsList_ be ? IterableToList(_elementObjects_).
        1. For each _elementObject_ in _elementObjectsList_, do
          1. Let _element_ be ? ToElementDescriptor(_elementObject_).
          1. Let _finisher_ be ? Get(_elementObject_, `"finisher"`).
          1. If _finisher_ is not *undefined*, throw a *TypeError* exception.
          1. Let _extras_ be ? Get(_elementObject_, `"extras"`).
          1. If _extras_ is not *undefined*, throw a *TypeError* exception.
          1. Append _element_ to _elements_.
        1. Return _elements_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-element-descriptor aoid=ToElementDescriptor>
      <h1>ToElementDescriptor ( _elementObject_ )</h1>
      <p>With parameter _elementObject_, returns an ElementDescriptor.</p>
      <emu-alg>
        1. Assert: _elementObject_ is an ECMAScript language value.
        1. Let _kind_ be ? ToString(? Get(_elementObject_, `"kind"`)).
        1. If _kind_ is not one of `"method"` or `"field"`, throw a *TypeError* exception.
        1. Let _key_ be ? Get(_elementObject_, `"key"`).
        1. Set _key_ to ? ToPrimitive(_key_, hint String).
        1. If _key_ is not a Private Name, set _key_ to ? ToPropertyKey(_key_).
        1. Let _placement_ be ? ToString(? Get(_elementObject_, `"placement"`)).
        1. If _placement_ is not one of `"static"`, `"prototype"`, or `"own"`, throw a *TypeError* exception.
        1. Let _descriptor_ be ? ToPropertyDescriptor(? Get(_elementObject_, `"descriptor"`)).
        1. Let _initializer_ be ? Get(_elementObject_, `"initializer"`).
        1. Let _elements_ be ? Get(_elementObject_, `"elements"`).
        1. If _elements_ is not *undefined*, throw a *TypeError* exception.
        1. If _kind_ not `"field"`,
          1. If _initializer_ is not *undefined*, throw a *TypeError* exception.
        1. If _key_ is a Private Name,
          1. If _descriptor_.[[Enumerable]] is *true*, throw a *TypeError* exception.
          1. If _descriptor_.[[Configurable]] is *true*, throw a *TypeError* exception.
          1. If _placement_ is `"prototype"` or `"static"`, throw a *TypeError* exception.
        1. If _kind_ is `"field"`,
          1. If _descriptor_ has a [[Get]], [[Set]] or [[Value]] internal slot, throw a *TypeError* exception.
        1. Let _element_ be the ElementDescriptor { [[Kind]]: _kind_, [[Key]]: _key_, [[Placement]]: _placement_, [[Descriptor]]: _descriptor_ }.
        1. If _kind_ is `"field"`, set _element_.[[Initializer]] to _initializer_.
        1. Return _element_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-element-finisher-extras aoid=ToElementFinisherExtras>
      <h1>ToElementFinisherExtras ( _elementObject_ )</h1>
      <p>With parameter _elementObject_, returns a Record containing three values: { [[Element]]: ElementDescriptor, [[Extras]]: an iterable of other Element Descriptors, [[Finisher]]: a Function or *undefined* }.</p>
      <emu-alg>
        1. Let _element_ be ? ToElementDescriptor(_elementObject_).
        1. Let _finisher_ be ? Get(_elementObject_, `"finisher"`).
        1. If IsCallable(_finisher_) is *false* and _finisher_ is not *undefined*, throw a *TypeError* exception.
        1. Let _extrasObject_ be ? Get(_elementObject_, `"extras"`).
        1. Let _extras_ be ? ToElementDescriptors(_extrasObject_).
        1. Return the Record { [[Element]]: _element_, [[Finisher]]: _finisher_, [[Extras]]: _extras_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-from-class-descriptor aoid=FromClassDescriptor>
      <h1>FromClassDescriptor ( _elements_ )</h1>
      <emu-alg>
        1. Assert: _elements_ is a List of ElementDescriptor.
        1. Let _elementsObjects_ be FromElementDescriptors(_elements_).
        1. Let _obj_ be ! ObjectCreate(%ObjectPrototype%).
        1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Class Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Perform ! DefinePropertyOrThrow(_obj_, @@toStringTag, _desc_).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"kind"`, `"class"`).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"elements"`, _elementsObjects_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-class-descriptor aoid=ToClassDescriptor>
      <h1>ToClassDescriptor ( _classDescriptor_ )</h1>
      <emu-alg>
        1. Let _kind_ be ? ToString(? Get(_classDescriptor_, `"kind"`).
        1. If _kind_ is not `"class"`, throw a *TypeError* exception.
        1. Let _key_ be ? Get(_classDescriptor_, `"key"`).
        1. If _key_ is not *undefined*, throw a *TypeError* exception.
        1. Let _placement_ be ? Get(_classDescriptor_, `"placement"`).
        1. If _placement_ is not *undefined*, throw a *TypeError* exception.
        1. Let _descriptor_ be ? Get(_classDescriptor_, `"descriptor"`).
        1. If _descriptor_ is not *undefined*, throw a *TypeError* exception.
        1. Let _initializer_ be ? Get(_classDescriptor_, `"initializer"`).
        1. If _initializer_ is not *undefined*, throw a *TypeError* exception.
        1. Let _extras_ be ? Get(_classDescriptor_, `"extras"`).
        1. If _extras_ is not *undefined*, throw a *TypeError* exception.
        1. Let _finisher_ be ? Get(_classDescriptor_, `"finisher"`).
        1. If _finisher_ is not *undefined*,
          1. If IsCallable(_finisher_) is *false*, throw a *TypeError* exception.
        1. Let _elementsObject_ be ? Get(_classDescriptor_, `"elements"`).
        1. Let _elements_ be ? ToElementDescriptors(_elementsObject_).
        1. Return the Record { [[Elements]]: _elements_, [[Finisher]]: _finisher_ }.
      </emu-alg>
    </emu-clause>

  </emu-clause>
</emu-clause>
